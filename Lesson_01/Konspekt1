Урок 1 - Написание кода для отобраежние его в командной строке:
Работа в Linux:
 _______________________________________________________ 
public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("- ZaOrdu?");
		System.out.println ("- Zaebis!")
		System.out.println ("- Даааа...");
	}
}
________________________________________________________
- public - модификатор, доступ для всех!;
- class ZaOrdu - это соглашение такое, что файл должен называться так же, как и класс, а 
class - это "кирпичик" из которого строится программа
* в 1 джава файле находится 1 класс, если программа состоит из нескольких классов, то каждый класс раскладывается в свой собственный исходный файл. 
Есть возможность в 1 файле объявлять несколько классов в 2ух вариантах 
1) 1-ый вариант, когда ещё один класс создается в основном классе:
________________________________________________________
public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("- ZaOrdu?");
		System.out.println ("- Zaebis!");
		System.out.println ("- Даааа...");
	}
        class Foo {}
}
________________________________________________________
2) 2-ой вариант, когда ещё один класс создается рядом, не имея модиифкатора public 
 public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("- ZaOrdu?");
		System.out.println ("- Zaebis!");
		System.out.println ("- Даааа...");
	}
}
class Bar {}
________________________________________________________
- main - это точка входа в программу (Чтобы Java-приложение могло работать, в каком-то его классе обязательно нужно объявить такую функцию main, как мы делали ранее во всех примерах)
- void (пустота) - модификатор (для окончания программы с нулевым кодом ошибки т.е.) при котором метод (main) не возвращает никакого значения (те идет линейная читка без запоминаня чисел, слов и прочих параметров);
**можно вместо модификатора void указать модификатор int (для завершенения программы с ненулевым кодом ошибки). Тогда можно написать код по суммированию 2ух чисел и прочее..:
________________________________________________________
int Sum(int first, int second) {
  return first + second;
}
int integer1 = 3;
int integer2 = 5;

int sum = Sum(integer1, integer2);
________________________________________________________
java - это компилируемый язык, поэтому компилятору надо заранее знать сколько памяти и где выделять, чтобы всё работало, потому что переменная - по сути это кусок памяти. 
и в переменную sum запишется значение 8, благодаря тому, что функция Sum имеет тип возвращаемого значения int - это значит, что 
first и second - это параметры, которые пришли откуда-то программы, где была вызвана функция Sum() 
return - возвращает значение из функции, то есть мы вызвали функцию, попали внутрь неё и начинаем построчновы выполнять что в ней написано
в данном случае у нас одна строка, которая складывает фёст и секонд, а потом делает возврат в точку кода, где функция была вызвана
- мы сначала были в строчке 1:
мы выделили 4 байта в оперативке (потому что int), записали туда значение 3, назвали это место "integer1"
- потом перешли к строчке 2:
мы выделили 4 байта в оперативке (потому что int), записали туда значение 5, назвали это место "integer2"
- перешли к строчке 3:
выделили 4 байта (потому что int) назвали это место sum и зашли внутрь функции Sum(), перед этим передав туда 2 переменных по 4 байта integer1 и integer2, в которых записаны 3 и 5
зашли в функцию Sum():
- в строчке 1 имеем в first то, что нам пришло из integer1, то есть 3, в переменной second у нас лежит то, что пришло из integer2, то есть 5; 
- переходим на строчку 2:
сначала выполняем операцию сложения, затем происходит вызов "return"
return возвращает 3+5 = 8
Правило - сначала надо объявить перменную только после можно присвоить значение

- static - модификатор, при котором метод можно создавать вызывать, не создавая экземпляр содержащего его класса (т.е. функция не пользуется членами того класса, к которому относится)

- String (строка) - тип данных, описывающий набор символов (иными словами — текст), который использует метод (main); например, "text"
- args - массив строк
String[] args - это переменная по которому передаётся путь к файлу исходников (java <имя файла> - путь, по которому программа должна пройти и взять именно этот файл, в котором написан код, что ей делать)
- System.out.println конструкция для печати даннх таких как  строка число, произвольные объекты при помощи добавления ln каждая последующая команда System.out.print будет выводится на новой строке
есть ещё конструкция 
- System.out.print он не добавляет перевод строки после выведенного значения 
Для написания кода необходимо cmd (командная строка Windows), sublime Text3 (редактор, в котором будет писать код) + созданный файл переименнованный в .java (который будет переносить в программу sublime text3)

- Создаем в папке техтовый документ с названием ZaOrdu и переводим его в в ZaOrdu.java
- Запускаем sublime Text3 и перетаскиваем файл ZaOrdu.java
- Пишем код 
________________________________________________________
public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("ZaOrdu?");
	}
}
________________________________________________________
**
Можно добавить нескольок строк: 
________________________________________________________
public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("- ZaOrdu?");
		System.out.println ("- Zaebis!");
	}
}
________________________________________________________
В системе Linux в командной строке русский язык читается автоматически в отличие от Windows, где надо было бы дополнительно прописывать функцию чтения Русского языка:
путь, где лежит программа java (C:\Program Files\Java\jdk-12.0.2\bin>) + код (chcp 65001) = 
___________________________________________________________
C:\Program Files\Java\jdk-12.0.2\bin>chcp 65001
Active code page: 65001

Далее пишем код:

public class ZaOrdu {
	public static void main (String [] args) {
		System.out.println ("- ZaOrdu?");
		System.out.println ("- Zaebis!");
		System.out.println ("- Даааа...");
	}
}
________________________________________________________
если русский не отображается нужно в настройках sublime (preferences-sittings) справа прописать код для отображения формата программы (UTF-8)
________________________________________________________
// Settings in here override those in "Default/Preferences.sublime-settings",
// and are overridden in turn by syntax-specific settings.
{
	"show_encoding" : true
}
________________________________________________________
после этого будет отображаться формат кода
если формат не UTF-8, нужно привести его в соответсиве и ещё раз попробовать в консоли активировать код chcp 65001
_________________________________________

- Запускаем командную строку:
pwd - функция, позволяющая смотреть дирректорию, в какой ты сейчас находишься
ls - функция, показывающая содержимое текущего каталога
cd - в любой каталог (папку) можно зайти посредством функции cd (имя каталога (папки)) 
cd .. - возвращает тебя на ступень назад (выше) в родительский каталог  
java - команда, запускающая файл с виртуальной машиной Java

дирректория, в которой находится файл java + javac + имя файла в расширении java
__________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ java ZaOrdu.java
__________________________________________________________

Для того, прочитать чтобы byte code (он в двоичном формате) в текстовом формате, нужно сохранить в формат class из формата java:
_________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ javac ZaOrdu.java
________________________________________________________ 
после  этого нужно в консоли использовать инструмент javap
javap - инструмент, который позволяет вывести byte code из двоичного формата в текстовый  
он запускается так:
-дирректория, в которой находится файл с рашриением class/ javap -v имя файла. 
__________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ javap -v ZaOrdu.class
___________________________________________________________
После этого нам выдается byte code в текстовом формате, который можно прочитать 

Compiled from "ZaOrdu.java"
public class ZaOrdu {
  public ZaOrdu();
  public static void main(java.lang.String[]);
}
sheriff@ubuntu:~/JavaLessons/Lesson_01$ javap -v ZaOrdu.class
Classfile /home/sheriff/JavaLessons/Lesson_01/ZaOrdu.class
  Last modified Jul 19, 2019; size 453 bytes
  MD5 checksum 35377c43fb67962e13ae85b727535b79
  Compiled from "ZaOrdu.java"
public class ZaOrdu
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #6                          // ZaOrdu
  super_class: #7                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #7.#16         // java/lang/Object."<init>":()V
   #2 = Fieldref           #17.#18        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #19            // - ZaOrdu!
   #4 = Methodref          #20.#21        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = String             #22            // - ZaOrdu!Ебать!
   #6 = Class              #23            // ZaOrdu
   #7 = Class              #24            // java/lang/Object
   #8 = Utf8               <init>
   #9 = Utf8               ()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               SourceFile
  #15 = Utf8               ZaOrdu.java
  #16 = NameAndType        #8:#9          // "<init>":()V
  #17 = Class              #25            // java/lang/System
  #18 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;
  #19 = Utf8               - ZaOrdu!
  #20 = Class              #28            // java/io/PrintStream
  #21 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V
  #22 = Utf8               - ZaOrdu!Ебать!
  #23 = Utf8               ZaOrdu
  #24 = Utf8               java/lang/Object
  #25 = Utf8               java/lang/System
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = Utf8               java/io/PrintStream
  #29 = Utf8               println
  #30 = Utf8               (Ljava/lang/String;)V
{
  public ZaOrdu();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String - ZaOrdu!
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        11: ldc           #5                  // String - ZaOrdu!Ебать!
        13: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        16: return
      LineNumberTable:
        line 3: 0
        line 4: 8
        line 5: 16
}
SourceFile: "ZaOrdu.java"
_____________________________________________________________________________________________________________

- Арифметические операции
Нам нужно попросить компьютер сложить 3 + 4 И дать команду сделать что-то с результатом. Например, вывести его на экран:
_____________________________________________________________________
System.out.print(3 + 4);
_____________________________________________________________________
class App {
    public static void main(String[] args) {
        //BEGIN
        System.out.print(3 + 4);
        //END
    }
}

_____________________________________________________________________
После запуска на экране появится результат 7. 
Производить вычисления подряд можно сколько угодно - такое свойство операций называется композицией. 

Кроме сложения доступны следующие операции:
* — умножение
/ — деление
- — вычитание
% — остаток от деления

- Операторы
Знак операции, такой как +,-,/,*,%, и т.д. называют оператором. 
Оператор — просто символ, который производит некоторую операцию. Операторы бывают не только арифметическими.
_____________________________________________________________________
System.out.print(8 + 2);
_____________________________________________________________________
В этом примере + это оператор, а числа 8 и 2 — это операнды.
В случае сложения у нас есть два операнда: один слева, другой справа от знака +. Операции, которые требуют наличия двух операндов, называются БИНАРНЫМИ.
Операции бывают не только бинарными, но и унарными (с одним операндом) и даже тернарными (с тремя операндами)!
Символы + и - используются не только как операторы. Когда речь идет про отрицательные числа, то знак минуса становится частью числа:
_____________________________________________________________________
System.out.print(-3); // => -3
_____________________________________________________________________

Коммутативная операция - «от перемены мест слагаемых сумма не меняется», это один из базовых и интуитивно понятных законов арифметики, он называется коммутативным законом.
Бинарная операция считается коммутативной, если, поменяв местами операнды, вы получаете тот же самый результат. Очевидно, что сложение — коммутативная операция: 3 + 2 = 2 + 3.

- Кавычки
Если мы хотим создать такую строку:
_____________________________________________________________________
Dragon's mother said "No"
_____________________________________________________________________
В ней есть и одинарные и двойные кавычки - для этого используют символ экранирования \ 
Если поставить \ перед кавычкой, это будет означать, что кавычку нужно рассматривать не как начало или конец строки, а как часть строки.
_____________________________________________________________________
System.out.print("Dragon's mother said \"No\"");
_____________________________________________________________________
- Экранирующие последовательности
перевод строки:
1. через конструкцию \n, но \n работают ТОЛЬКО внутри двойных кавычек!
_____________________________________________________________________
System.out.print("- Are you hungry?\n- Aaaarrrgh!"); 
_____________________________________________________________________
результат:
- Are you hungry?
- Aaaarrrgh!
Либо System.out.print("Gregor Clegane\nDunsen\nPolliver\nChiswyck");
выведется:
Gregor Clegane
Dunsen
Polliver
Chiswyck
Также можно использовать n\ в конструкции 
_____________________________________________________________________
System.out.print("Gregor Clegane");
System.out.print("\n");
System.out.print("Dunsen");
_____________________________________________________________________
результат:
Gregor Clegane
Dunsen
***
Если нам понадобится вывести \n именно как текст (два отдельных печатных символа), то можно воспользоваться уже известным нам способом экранирования, добавив еще один \ в начале. То есть последовательность \\n отобразится как символы \ и n идущие друг за другом.
_____________________________________________________________________
System.out.print("Joffrey loves using \\n");
_____________________________________________________________________
на экран выйдет:
Joffrey loves using \n

2. Перевод строки можно использовать также через конструкцию System.out.println
_____________________________________________________________________
System.out.println("Hello");
System.out.println("World");
_____________________________________________________________________
Hello
World

Чтобы вывести команду на экран 
- Did Joffrey agree?
- He did. He also said "I love using \n".
нужно ввести команду:
_____________________________________________________________________
System.out.println("- Did Joffrey agree?");
System.out.println("- He did. He also said \"I love using \\n\"");
___________________________________________1______________2___1_____________
либо 
_____________________________________________________________________
System.out.print("- Did Joffrey agree?\n- He did. He also said \"I love using \\n\".");
_____________________________________________________________________

- Конкатенация - склеивание
Грубо говоря, это «склеивание» строк System.out.print("Dragon" + "stone"); 
=> Dragonstone
Склеивание King’s Landing (с пробелом) путем данной конструкции возможно 3 способами 
_____________________________________________________________________
System.out.print("King's " + "Landing"); //  => King's Landing
_____________________________________________________________________
System.out.print("King's" + " Landing"); //  => King's Landing
_____________________________________________________________________
System.out.print("King's" + " " + "Landing"); //  => King's Landing
_____________________________________________________________________

- Кодировка
На самом глубоком уровне компьютер оперирует исключительно цифрами 0 и 1. Это так называемый двоичный код, а 1 и 0 называются битами, от “binary digit” — «двоичная цифра».
Обычные, привычные нам числа в десятичной системе счисления, закодированы с помощью двоичных чисел:
0 ← 0
1 ← 1
2 ← 10
3 ← 11
4 ← 100
5 ← 101
https://habr.com/ru/post/124395/ (статья на хабре про Основы систем счисления)
 Но как быть с текстом? Компьютер на самом деле не знает ничего о буквах, знаках пунктуации и прочих текстовых символах. Все эти символы так же закодированы числами.
Можно взять английский алфавит и дать каждой букве число, начиная с единицы по порядку:
a ← 1
b ← 2
c ← 3
d ← 4
…
z ← 26
 Далее можно научить компьютер понимать эту таблицу и переводить текст в числа и наоборот — числа в текст:
hello → 8 5 12 12 15
7 15 15 4 → good
 В этом заключается суть кодировок.
 Кроме букв алфавита, в таблицы кодировок входят знаки препинания и другие полезные символы. Вы наверняка сталкивались с кодировками, например, ASCII или UTF-8.
 Разные кодировки содержат разное количество символов. Изначально небольших таблиц вроде ASCII было достаточно для большинства задач. Но в ней только латинские буквы, несколько простых символов вроде % и ? и специальные управляющие символы типа перевода строки.
 С распространением компьютеров, разным странам понадобились свои, более широкие таблицы. В том числе для кириллических букв, восточных иероглифов, арабской вязи, дополнительных математических и типографских символов, а впоследствии даже для эмодзи-смайликов.
 Сегодня в большинстве случаев используется один из вариантов юникода, включающий в себя знаки почти всех письменных языков мира.
 Задание
В Java можно «запросить» и вывести на экран любой символ из кодировки ASCII. 
_____________________________________________________________________
System.out.print((char)63);
_____________________________________________________________________
На экран выведется символ с номером 63 — вопросительный знак ?. Таким способом можно выводить любой символ.
Ссылка на таблицу кодов ASCII: 
https://yadi.sk/i/aueLRAxT7LAjAQ
Нас интересует десятичный код (dec или decimal) 
Используя пример выше и найденную таблицу, выведите на экран ~^%.
_____________________________________________________________________
System.out.print((char)126);
System.out.print((char)94);
System.out.print((char)37);
_____________________________________________________________________

- Типы данных в Java. 
Тип данных определяет, что можно делать с элементами конкретного множества информации
1. Строки в кавычках
2. Числа 7, -198, 0 и так далее
Java не позволит нам умножать текст на текст, но позволит умножать целое число на другое целое число.            
В отличие от строк, числа оборачивать в кавычки не нужно.
ВАЖНО, что число 5 и строка "5" — совершенно разные вещи, хотя вывод у System.out.print для этих данных идентичный.
Целые числа (1, 34, -19 и т.д.) и рациональные числа (1.3, 1.0, -14.324 и т.д.) — это два отдельных типа данных. 

- Явное преобразование типов.
Язык Java является языком со строгой типизацией. Используя специальный синтаксис возможно осуществить преобразование типов: 
_____________________________________________________________________
System.out.print(Integer.parseInt("345"));
_____________________________________________________________________
 Преобразование типа работает так - перед значением, в скобках, указывается желаемый тип. В результате значение справа преобразуется в значение другого типа, указанного слева в скобках.
 Преобразование типов можно использовать внутри составных выражений:
_____________________________________________________________________
// Дополнительные скобки помогают визуально отделить части выражения друг от друга.
System.out.print("Это " + ((int) 5.1));
_____________________________________________________________________
В данном случае, не смотря на то, что 5.1 является числом, но тип у него не int, а double, выражение выше приводит это число к int, отбрасывая дробную часть, т.к. тип int не хранит дробную часть числа, поэтому команда будет выведена на экран как: 
Это 5

Ещё один пример Преобразования, когда число переводится в симов или буквы через Кодировку
Простой пример: 
_____________________________________________________________________
public class ZaOrdu {
	public static void main (String [] args) {
	    System.out.print((char)63);
	//хуимбала преобразует из десятичного кода цифры 63 в символ ?
	}
}
_____________________________________________________________________

***Более сложный пример с применением цикличной функции уравнения:
_____________________________________________________________________
public class App {
    public static void main(String[] args) {
    	System.out.print("строка кода \"System.out.println(126);\" выводит на экран: ");
    	System.out.println(126);

    	System.out.print("строка кода \"System.out.println((char)126);\"  выводит на экран: ");
        System.out.println((char)126);

        System.out.println("\n\nВыводим числа от 0 до 255 через пробел в строку");
        System.out.println("----------------------");
        for(int i = 0; i < 256; i++) {
        //чтоб 256 раз не писать преобразования от 0 до 256 в символы
        //можно поставить цикл при помощи for, обязательно посавив цикл в скобки {}
            System.out.print(i);        	
            System.out.print(" ");
        }
        // цикл закончился и скобки закрылись!
        System.out.println("\n----------------------");

        System.out.println("\n\nВыводим числа от 0 до 255, преобразованные к типу char через пробел в строку");
        System.out.println("----------------------");
        for(int i = 0; i < 256; i++) {
        //также начался цикл преобразований по формуле
            System.out.print((char)i);        	
            System.out.print(" ");
        }
        // цикл закончился, скобки обязательно закрыть!
        System.out.println("\n----------------------");
    }
}
_____________________________________________________________________

Ещё один пример преобразования с типом данных (double), который записывает числовую переменную в память: 
_____________________________________________________________________
public class App {
    public static void main(String[] args) {
        
        //Объявили переменную типа double и проинициализировали 
        //её значением 65.5
        double ebanaya_peremennaya = 65.5;
 	//после написания компилятор знает, что в оперативке надо заранее выделить 8 байт памяти, где будет хваниться число 65.5 для последующих операций с ним

        System.out.println(ebanaya_peremennaya);
        System.out.println((int)ebanaya_peremennaya);
        System.out.println((char)ebanaya_peremennaya);
    }
}
_____________________________________________________________________
Получили: 
65.5 - System.out.println(ebanaya_peremennaya);
65   - System.out.println((int)ebanaya_peremennaya);
A    - System.out.println((char)ebanaya_peremennaya);
______________________________________________________________________

- Что такое переменная 
Переменная бывает в виде символов, целых чисел, вещественных чисел, строки (слова, тексты)
Для таких переменных существуют свои операторы 
char - для символов
int - для целых чисел
double - для вещественных чисел
String - для строк, слов, текстов 
 Главное правило: переменная должна быть объявлена до ее использования. Если сделать это позже, то программа просто не заработает: 

System.out.print(greeting);
greeting = "Father!";
Запуск программы выше завершается с ошибкой - Error: java: cannot find symbol symbol: variable greeting

Например использования переменных:
______________________________________________________________________
public class App {
    public static void main(String[] args) {
    double ebanaya_peremennaya1 = 65.5;
    String ebanaya_peremennaya2 = "За Орду!";
    String res = ((int) ebanaya_peremennaya1) + "\n" + ((char) ebanaya_peremennaya1) + "\n" + (ebanaya_peremennaya2);
        // int и string разные типы, но res - стринговая переменная
        //значит все привелось к типу String - ЗБСь сработало!
        System.out.println(res);
	// res - записывает все предыдущие действия и с помощью оператора System.out.println выводит команду 
______________________________________________________________________	
на экран выводится 
65
A
За Орду!

**НО если в классе используются только вещественные числа, то код с оператором res будет  выглядить следующим образом:
______________________________________________________________________
public class App {
	public static void main(String[] args) {
	double FirstNumber = 1.10;
        double SecondNumber = -100;
	//можно и без оператора rest - сразу переходить к конструкции System.out.print
        double res = (FirstNumber * SecondNumber);
        System.out.print(res);
    }
}
______________________________________________________________________
!!!! НОВАТОРСТВО !!!
опретор var 
всемогущая ебала, которая заменяет все операторы, вне зависимости от типа данных =>
______________________________________________________________________
public class App {
    public static void main(String[] args) {
        var ebanaya_peremennaya1 = 65.5;
        var ebanaya_peremennaya2 = "За Орду!";
        var res = ((int) ebanaya_peremennaya1) + "\n" + ((char) ebanaya_peremennaya1) + "\n" + (ebanaya_peremennaya2);
        System.out.println(res);
	// res - записывает все предыдущие действия и с помощью оператора System.out.println выводит команду 
_____________________________________________________________________
Также переменную можно переименовать походу написания кода слудющим образом:

var name = "Brienna";

        // BEGIN
        name = "Anneirb";
        // END

        System.out.print(name);
______________________________________________________________________
На экран выводится Anneirb

Вывод цифр с помощью конкатенации без их сложения с новой строки в одной команде
______________________________________________________________________
public class ZaOrdu {
        public static void main(String[] args) {
            var euros = 100;
            var DollarPerEuros = euros * 1.25;
            var RublesPerDollar = DollarPerEuros * 60;
	    //либо так...
            var res = ((DollarPerEuros) + "\n" + (RublesPerDollar));
            System.out.print(res);
	    // либо через 
	    //System.out.print(DollarPerEuros + "\n" + RublesPerDollar);

            }
        }

125.0
7500.0
_____________________________________________________________________
Также  спомощью оператора var можно строить большие текстовые читабельные конструкции System.out.print
_____________________________________________________________________
public class App {
    public static void main(String[] args) {
        var info = "We couldn't verify you mother's maiden name.";
        var intro = "\nHere is important information about your account security.";

        var firstName = "Joffrey";
        var greeting = "Hello";

        // BEGIN
        System.out.print(greeting + ", " + firstName + "!");
        System.out.print(intro + "\n" + info);
        // END
    }
}
_____________________________________________________________________
***
Магические числа (magic numbers) или "запах" кода, когда числа существуют в коде без придания им наименования переменной, т.е. при наприсании кода:
var euros = 1000;
var dollars = euros * 1.25; // => 1250
var rubles = dollars * 60; // => 75000
System.out.print(rubles);
спустя 3 года или другому разработчику будет сожно догадаться, что обозначают числа 60 и 1.25 
Для того, чтобы код могли более проще прочитать - правильно создавать переменные на выбранные числа
_____________________________________________________________________
var dollarsInEuro = 1.25;
var roublesInDollar = 60;

var euros = 1000;
var dollars = euros * dollarsInEuro; // => 1250
var rubles = dollars * roublesInDollar; // => 75000

System.out.print(rubles);
_____________________________________________________________________

- Константы - принято именовать буквами в верхнем регистре 
final var (имя константы (любой тип данных)
_____________________________________________________________________
final var PI = 3.14;
System.out.print(PI); // 3.14
_____________________________________________________________________

- Извлечение символов из строки по команде 
charAt(int index) — это специальный метод извлечения символа из строки. Индекс — это позиция символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования — поэтому, чтобы получить первый символ, нужно указать индекс 0
 System.out.print(имяПеременнойИлиКонстанты.charAt(номер символа из переменной или константы, начиная с 0));
_____________________________________________________________________
var firstName = "Alexander";
System.out.print(firstName.charAt(0)); // => A
_____________________________________________________________________
Иногда нужно получить один символ из строки. Например, если сайт знает имя и фамилию пользователя, и в какой-то момент требуется вывести эту информацию в формате A. Ivanov, то нужно взять первый символ из имени.
Индекс (т.е. номер извлекаемого символа из строки) можно также записывать в переменную командой var 
_____________________________________________________________________
var firstName = "Alexander";
var index = 0;
System.out.print(firstName.charAt(index)); // => A
_____________________________________________________________________
**НО! 
Но нужно конкатенировать (склеивать) символы друг с другом, а не со строкой - компилятор Java решит, что вы хотите сложить числовые коды этих символов, и результатом будет какое-то число.
_____________________________________________________________________
System.out.print('H' + 'A');        // => 137 (переводит в символы десятичной системы исчисления (т.е. цифры) и складывает 72 + 65 
System.out.print('H' + " " + 'A');  // => "H A"
_____________________________________________________________________
Вам даны три переменные с фамилиями разных людей. Составьте и выведите на экран слово из символов в таком порядке:
var one = "Naharis";
var two = "Mormont";
var three = "Sand";
третий символ из первой строки;
второй символ из второй строки;
четвертый символ из третьей строки;
пятый символ из второй строки;
третий символ из второй строки.
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
	var one = "Naharis";
	var two = "Mormont";
        var three = "Sand";
       

        // BEGIN
        System.out.print(one.charAt(2) + " " + two.charAt(1) + " " + three.charAt(3) + " " + two.charAt(4) + " " + two.charAt(2));
        // END

    }
}
_____________________________________________________________________
 либо с оператором var 
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
	var one = "Naharis";
	var index1 = 2;
        var two = "Mormont";
        var index2 = 1;
        var index4 = 4;
        var index5 = 2;
        var three = "Sand";
        var index3 = 3;

        // BEGIN
        System.out.print(one.charAt(index1) + " " + two.charAt(index2) + " " + three.charAt(index3) + " " + two.charAt(index4) + "\n");
        // END

    }
}
_____________________________________________________________________

					Функции Java и их вызов

1. Нахождения минимального числа из двух - Math.min
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
	var result = Math.min(1, 5);
        System.out.print(result + "\n");
        // END

    }
}

1
_____________________________________________________________________

2. Считет длину строки (количество символов в строке, с пробелами и прочими знаками, символами)- length
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
	var result = "Hello world!".length(); \\ т.е. в данно строке 12 символов 
        System.out.print(result + "\n");
        // END

    }
}

12
_____________________________________________________________________

3. calculateDistance - высчитывающую расстояние в ЗАРАНЕЕ ПРОПИСАННОЙ ФУНКЦИИ
_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception {
        // BEGIN посчитаем расстояние между двумя городами  при помощи функции 
	//самозоднанной функции calculateDistance
        var sity1 = "Qarth";
	var sity2 = "Vaes";
	var distance = Functions.calculateDistance(sity1 sity2);
	System.out.print(distance);
        // END 
    }
}
_____________________________________________________________________
либо 
_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception {
        // BEGIN посчитаем расстояние между двумя городами  при помощи функции 
	//самозоднанной функции calculateDistance
        var distance = Functions.calculateDistance("Qarth", "Vaes");
	System.out.print(distance);
        // END 
    }
}
_____________________________________________________________________
НО Functions.calculateDistance может вычислять расстояние только между двумя точками
поэтому для вычисленя общего расстояния между 3мя и более городами 
_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception {
        // BEGIN посчитаем расстояние между двумя городами  при помощи функции 
        var distance = Functions.calculateDistance("Winterfell","The Twins");
        var distance1 = Functions.calculateDistance("The Twins", "The Eyrie");
        System.out.print(distance + distance1);
        // END 
    }
} 
_____________________________________________________________________

4. concat - функция последовательно объединяет (а не складывает) строку (с любым типом данных) с другой строкой  
_____________________________________________________________________
"cares".concat("s") returns "caress"
 "to".concat("get").concat("her") - returns "together"
_____________________________________________________________________
 Чем-то похожа на «склеивание» строк System.out.print("Dragon" + "stone"); //=> Dragonstone
_____________________________________________________________________
public class App {
    public static void main(String[] args) {
        var result = "Hello";
        var text = " world!";
        // BEGIN
        System.out.print(result.concat(text).concat(" ").concat("?").concat("99").concat("\n"));
        // END
    }
}
//Hello world! ?99
sheriff@ubuntu:~/JavaLessons/Lesson_01$
_____________________________________________________________________
Очень важно про склеивание (concat) и складывание (+)
*** НО соединять аргументы можно только типа String (т.е. слова или строки (не цифры) 
т.е. 
_____________________________________________________________________
public class App {
    public static void main (String[] args) {
    	var t1 = 1; // без кавычек
    	var t2 = 2; // не получится склеить 
    	System.out.print(t1.concat(t2)); 
    } 
    
}

Ошибка...
_____________________________________________________________________
***// если склеивать (concat), складывать (+) в "цифры" получится всегда склеивание, т.е. "1" + "2" = 12, также с функцией concat


5. Math.round - функция округления числа до целого
_____________________________________________________________________

	var number = 7.7
	var nN = Math.round(number);
	System.out.print(nN);
8
_____________________________________________________________________

6. toUpperCase - функция переводит значения в верхний регистр (В ВЕРХНИЙ РЕГИСТР - збсь - ЗБСЬ)
_____________________________________________________________________
	var number = "xxx"
	number = number.toUpperCase();
	System.out.print(number);
XXX
_____________________________________________________________________

7. length - функция, которая считает количество символов в строке (в слове в цифре и т.д.)
 используется как: ebanaya_peremennaya.length()
                                              ^---- вот эти скобки пустые (ебола) обязательны 

public class App {
  public static void main(String[] agrs) {
    var password = "qwertytyyfg";
    System.out.println(password.length());
  }
}

11
_____________________________________________________________________  
Другой более сложный пример выводит 3 аргумента, считает их количтесво строк и если выполняется условие 
True, иначе False


public class Main {


    public static boolean passwordLengthIsCorrect(int length) {
        boolean result = (length > 8) && (length < 20);
        return result;
    }

    //у тебя программа всегда с мейна начинает исполняться,
    // как ты уже писал в своих конспектах, мейн - это точка входа в программу
    public static void main(String[] args) { // - с этого начинает читаться программа
        // вот есть 3 пароля
        var pass1 = "qwerefrwefwerfwerfwerfwerfefrwerfwrf";
        var pass2 = "qwertty";
        var pass3 = "qwertyui9";

        var pass1_len = pass1.length();
        var pass2_len = pass2.length();
        var pass3_len = pass3.length();

        System.out.println("длина пароля " + pass1 + " = " + pass1_len);
        System.out.println("длина пароля " + pass2 + " = " + pass2_len);
        System.out.println("длина пароля " + pass3 + " = " + pass3_len);

        //длина пароля qwer = 4
        //длина пароля qwertty = 7
        //длина пароля qwertyui9 = 9
        //всё верно)

        System.out.println("------------------------");



        boolean res1 = passwordLengthIsCorrect(pass1_len);
        boolean res2 = passwordLengthIsCorrect(pass2_len);
        boolean res3 = passwordLengthIsCorrect(pass3_len);

        System.out.println("пароль " + pass1 + " корректный? = " + res1);
        System.out.println("пароль " + pass2 + " корректный? = " + res2);
        System.out.println("пароль " + pass3 + " корректный? = " + res3);

    }
}

7. 	%s - слово (строка) String
	%d - количетсов нулей перед double или int 
	%f - количетсво нулей после запятой double или int

Совмещение аргументов с разными типами данными в оной функции при момощи - специальные заполнители "заглушка для строки" используется для выведение данных определенного формата на экран. Всегда используется с printf:

_____________________________________________________________________
System.out.printf("Today is %s %d", "February", 8); //помимо заглушек используется новая конструкция printf
Today is February 8
_____________________________________________________________________
Это «заглушки» для информации, которая передаётся следующими аргументами. %s означает «заглушка для строки», %d — для числа. Поэтому следующие два аргумента в нашем примере — строка и число.
** также вместо аргументов можно использовать переменные, функции, которые выдают значения, соответствующие %s (строка) %d (число)
** также в конструкции System.out.printf можно вставлять сколько угодо заглушшек для соотвествующего типа данных 
_____________________________________________________________________
System.out.printf("Today is %s %d %d", "February", 8, 33);

Today is February 8 33
_____________________________________________________________________
** также аргументы внутри конструкции System.out.printf можно складывать, вычитать и использовать любые функции, применимые к функциям Java 
_____________________________________________________________________
System.out.printf("Today is %s %d", "February", 33 - 3);

Today is February 30
_____________________________________________________________________
** (скольок угодно нолей перед цфирой) при выводе дат иногда требуется фиксировать количество цифр, скажем, всегда писать нули перед числом если число меньше 10.
 printf позволяет решить эту задачу при помощи заглушки %0"n"d, где n - любое целое
 %02d — сделать две цифры и заполнить нулями оставшееся пространство. %03d — три цифры, и так далее:

System.out.printf("Today is %s %03d", "February", 8);

Today is February 008
_____________________________________________________________________
** также %d и %s задают формат последующего вывода данных, те если написать 
printf("%d-%s", number, kakoetoSlovo);
//на экран выведется формат через дефис: 
число-какоетоСлово

				Задание
 Реализуйте функцию printFormattedBirthday, которая принимает на вход три параметра: день, месяц и год рождения, а печатает их строкой в отформатированном виде, например: 30-02-1953.
 День и месяц нужно форматировать так, чтобы при необходимости добавлялся 0 слева. Например, если в качестве месяца пришла цифра 7, то в выходной строке она должна быть представлена как 07.
_____________________________________________________________________
Решение учителя в той программе: 

public class App {
    // BEGIN
    public static void printFormattedBirthday(int day, int month, int year) {
        System.out.printf("%02d-%02d-%d", day, month, year);
    }
    // END
}

_____________________________________________________________________
Мое решение в Sublime:

public class App {
	public static void main(String[] args) {
		App.printFormattedBirthday(30, 2, 1953);
	}
	static void printFormattedBirthday(int d, int m, int y) {
	System.out.printf("%02d-%02d-%02d", d, m, y);
	}

}
_____________________________________________________________________
8. Логический тип - boolean / если условие верное - True, если условие не выполняется - False

 Список операций сравнения:
	a) < меньше
	a) <= меньше или равно
	a) > больше
	a) >= больше или равно
	a) == равно
	a) != не равно
	b) && конъюнкция - означает «и то, и другое»                    //Операторы можно комбинировать в любом количестве
	c) || дизъюнкция - означает «или то, или другое, или оба».     // и в любой последовательности, но когда одновременно встречаются && и ||,
								      //то приоритет лучше задавать скобками.


 Логическая операция типа 5 > 4 — это выражение, и его результат — значение логического типа. 
 Логический тип в Java - bool - это значение, которое записывается как true («истина») или false («ложь»), например var isFivePositive = (5 > 0).
+
9. Функция - предикат (отвечает на утвердительный вопрос «да» или «нет», возвращая значение типа boolean)
 В Java предикаты как правило начинаются с префикса is или has:
	isInfant — «младенец ли?»
	hasChildren — «есть ли дети?»
	isEmpty — «пустой ли?»
	hasErrors — «есть ли ошибки?»
**ВАЖНО!! - Функция (is и has) может считаться предикатом, только если она возвращает boolean.

 
 Так выглядит Функция, которая принимает на вход возраст ребенка в годах (целое число - тип int) и определяет, младенец ли он. Младенцами считаются дети до года (8.a) + 9.):
_____________________________________________________________________
Убаное решение учителя:

public static void main(String[] args) {
  System.out.print(isInfant(3));
}

static boolean isInfant(int age) {
  return age < 1;
}

false
_____________________________________________________________________
Моё решение:

public class App {
    // BEGIN
    public static void main(String[] args) {
		System.out.print(isInfant(0.3));
    }
	static boolean isInfant(double age) {
		return age < 1;
	}
    // END
}
_____________________________________________________________________
 
 Задание (8.a) + 9.) 
 Напишите функцию isPensioner, которая принимает возраст в качестве единственного аргумента и проверяет, является ли этот возраст пенсионным. Пенсионным считается возвраст 60 лет и больше
_____________________________________________________________________
Моё решение:
public class App {
    // BEGIN
    public static void main(String[] args) {
		System.out.print(isPensioner(60.3));
    }
	static boolean isPensioner(double age) {
		return age >= 60;
	}
    // END
}
_____________________________________________________________________
Убаное решение учителя: 

public class App {
    // BEGIN
    public static boolean isPensioner(int age) {
        return age >= 60;
    }
    // END
}
_____________________________________________________________________
 
 Задание (8.a) + 9.) 
 Напишите функцию isNegative, которая принимает число и проверяет, является ли оно отрицательным.
_____________________________________________________________________
Моё решение: 

public class App {
    // BEGIN
    public static void main(String[] args) {
		System.out.print(isNegative(-0.25));
    }
	static boolean isNegative(double q1) {
		return q1 < 0;
	}
    // END
}

true
_____________________________________________________________________
Убаное решение учителя: 

    // BEGIN
     public static boolean isNegative(int q) {
        return q < 0;
    }
    // END
}
_____________________________________________________________________

10. if, else| if, esle if, else| - использование условий и комбинирование с п.8


					Задача! (если больше меньше) (7.(%) + 8.(b) && (конъюнкция - означает «и то, и другое») + 10.)
  
нам надо вывести на экран дату 01-02-1999 через придуманную функцию Dd
не через формат prinf("%02d-%02d-%02d", n1, n2, n3), а через 
условия
если n1,n2,n3 от 0 до 10, тогда используется %02d, (т.е. 01, 02,..09)
иначе всегда используется %d (10, 11, 12...n)
Иначе говоря, нам надо прописать условия для каждого аргумента (переменной):
если n1 = 1, n1 < 10 тогда используется %02d, в остальных случаях, когда 
n1 > 10 используется %d
и уже в конечном printf просто написать 
printf(n1, n2, n3) (либо первести в перменную и тогда написать 
printf (a, b, c)
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
		App.dd(5, 3, 1953);
	}
	//вот функция
	//тут получили    -----------------------------------
	//                                                  | //без  String xyu не получится записать "-" 
	//                                                  V // в функции print_number
	public static void print_number(int number, String xyu){
		if (number > 0 && number < 10) {
			System.out.printf("%02d%s", number, xyu);
		}
		else {
			System.out.printf("%d%s", number, xyu);
		}
	}
	public static void dd(int a, int b, int c) {
		//----------------------
		//тут передали ----
		//                |
		//                V 
		print_number(a, "-"); //тут передаём то что пришло в переменну а, и -
		//----------------------
		print_number(b, "-"); //тут передаём то что пришло в переменну а, и -
		//----------------------
		print_number(c, "\n"); //тут передаём то что пришло в переменну а, и \n
	}
}
_____________________________________________________________________

 Задача на 3 ЕСЛИ if, esle if, else (если, если иначе, иначе)  
Решить квадратное уравнение (ах^2+bx+c=0)
_____________________________________________________________________
public class Main {
    public static void main(String[] args) { // - с этого начинает читаться программа
// ax^2+bx+c=0 D = b^2 - 4ac
        double a = 2;
        double b = -54;
        double c = 11;
        double D = Math.pow(b, 2) - 4 * a * c;

        D = Math.pow(b, 2) - 4 * a * c;
        if (D > 0) {
            double x1 = -b + Math.sqrt(D) / (2 * a);
            double x2 = -b - Math.sqrt(D) / (2 * a);
            System.out.printf("x1 = %s, х2 = %f \n", x1, x2);
        } else if (D == 0) {
            double x = -b / 2 * a;
            System.out.printf("D = %f \n", x);
        }
        else {
            System.out.println("D<0, there is no roots, PZDUk");
        }
    }
}
_____________________________________________________________________

11. Оператор % вычисляет остаток от деления 
7 % 2 → 1
21 % 3 → 0
19 % 5 → 4

** например, в программировании провереяте четность чисел и спольщуьзуют деление на 2 
- если остаток 0, то число было чётным
- если остаток не 0, то число было нечётным
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
		System.out.println(App.Even(78));
	}
	static int Even(int number) {
		return number % 5;
	}
	
}

3
_____________________________________________________________________

Задание - 
С помощью оператора 11(%) + 8.(boolean(true|false) + 8.(==) напишем функцию проверки чётности:  
_____________________________________________________________________
public class App {
    // BEGIN
    public static void main(String[] args) {
    	System.out.print(isEven(78));
		}
	static boolean isEven(int number) {
		return number % 2 == 0;
	}
    // END
}

//True
//Приоритет арифметических операций выше логически, поэтому 
return number % 2 == 0; 
// сначала вычисляется арифметическое выражение number % 2, затем результат участвует в логическом сравнении
_____________________________________________________________________

 Задание!
Используем в 1 классе 2 функции (1 при этом созданная нами):
 Создаем функцию App.Even() которая выдает остаток аргумента функции (% 5) и помещаем её в условие, 
если "результат функции" > 10, выводим на экран %02d (т.е. 0"результат функции(03))
если "результат функции" < 10, выводим на экран %05d (т.е. 0000"результат функции)(00003))
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
		print_n(App.Even(78));
	}
	static int Even(int number) {
		return number % 5;
	}
	static void print_n(int n1) {
		if (n1 > 10) {
			System.out.printf("%02d\n", n1);
		}
		else {
			System.out.printf("%05d\n", n1);
		}
	}
}

00003
_____________________________________________________________________

Задание - проверка пароля от 8 до 20 символов в длину.
 Вот функция, которая принимает пароль и говорит, соответствует ли он условиям (true) или не соответствует (false):
__________________________________________________________________________________________________________________________________________
1ый вариант:

public class App {
    public static boolean isCorrectPassword(String password) {
    int length = password.length();
    return length > 8 && length < 20;
  }

  public static void main(String[] agrs) {
    System.out.println(isCorrectPassword("qwerty")); // => false
    System.out.println(isCorrectPassword("qwerty1234")); // => true
    System.out.println(isCorrectPassword("zxcvbnmasdfghjkqwertyui")); // => false
  }
__________________________________________________________________________________________________________________________________________
2ой вариант по новой методике: 
 
public static void main(String[] args) {
		// вот есть 3 пароля
		String pass1 = "qwerefrwefwerfwerfwerfwerfefrwerfwrf";
		String pass2 = "qwertty";
		String pass3 = "qwertyui9";

		int pass1_len = pass1.length();
		int pass2_len = pass2.length();
		int pass3_len = pass3.length();

		System.out.println("длина пароля " + pass1 + " = " + pass1_len);
		System.out.println("длина пароля " + pass2 + " = " + pass2_len);
		System.out.println("длина пароля " + pass3 + " = " + pass3_len);
		
		//длина пароля qwer = 4
        //длина пароля qwertty = 7
        //длина пароля qwertyui9 = 9
		//всё верно)

		System.out.println("------------------------");

		boolean res1 = passwordLengthIsCorrect(pass1_len);
		boolean res2 = passwordLengthIsCorrect(pass2_len);
		boolean res3 = passwordLengthIsCorrect(pass3_len);

		System.out.println("пароль " + pass1 + " корректный? = " + res1);
		System.out.println("пароль " + pass2 + " корректный? = " + res2);
		System.out.println("пароль " + pass3 + " корректный? = " + res3);

	}

	public static boolean passwordLengthIsCorrect(int length) {
		return (length > 8) && (length < 20);
	}
}
__________________________________________________________________________________________________________________________________________

13. import java.util.Scanner - ввод данных через экран консолья (через экран среды разработки) 
			
					Задачи для падавана-Шериффа от магсира-Артёма

Задача №1 - найти площадь круга с помощью ввода данных черех экран (консоль, в среде)
//import - это ключевое слово языка java, с помощью которого подключаются различные библиотеки
import java.util.Scanner; //это библиотека, которую необходимо импортировать в проект, для того, чтобы заюзать сканер
___________________________________________________________________________________________________
public class Main {
    public static void main(String[] args) { // - с этого начинает читаться программа
        //у любой консольной программы есть возможность выводить данные на экран
        //вводить данные с клавиатуры

        //сканер - это какой-то объект, котьорый позволяет нам вводить данные с клавиатуры
        // System.in - это стандартный поток ввода-----
        //                                            |
        //                                     -------
        //                                    |
        //                                    V
        Scanner scanner = new Scanner(System.in); //тут мы создали переменную scanner (объект) типа Scanner.
        // (тип данных называется Scanner) - этот тип данных создали другие программисты
        // на основе стандартных типов данных и возможностей языка джава
        // и запихнули его в стандартную библиотеку под названием java.util.Scanner
        // тип переменной ------      название переменной --
        //                      |                          |     ---- new означает, что мы создаём переменную в "куче"
        //     -----------------                          |     |        ----- вызываем конструктор объекта (функцию, которая создаёт объект)
        //    |                                          |     |        |
        //   |         ---------------------------------      |        |
        //  |         |          ----------------------------         |      ----- конкретно этот конструктор принимает какой-то параметр.
        // |         |          |      -------------------------------      |      мы передаём туда System.in, потому что он соответствует типу,
        // |         |         |      |      -------------------------------       который может принять конструктор
        // |         |        |      |      |
        //Scanner scanner = new Scanner(System.in);

        //эту строчку мы знаем: тут в консоль выводится текст, написанный в кавычках
        System.out.print("Введите радиус круга: ");

        //тут мы объявили переменную типа double, дали ей имя radius и присвоили ей значение 0
        double radius = 0;

        //здесь мы у объекта сканер вызвали функцию nextDouble(), которая, очевидно, ожидает от нас, что мы введем с клавиатуры число типа double
        //программа повиснес здесь, до тех пор, пока мы не что-нибудь не наберём с клавиатуры и не нажмём энтер
        radius = scanner.nextDouble(); // nextDouble() - это функция, которая возвращает значение типа дабл из объекта сканер

        //выводим то, что записалось в переменную radius
        System.out.printf("Радиус круга: %f \n", radius);

        //объявляем переменную типа double, даём ей имя square и записываем туда 0
        double square = 0;

        //вычисляем площадь круга
        //вот тут у нас явно напрашивается запилить этот код в функцию, вычисляющую квадрат
        square = 3.14 * calculateSquare(radius);

        //выводим на экран площадь круга
        System.out.printf("Площадь круга: %f \n", square);

        //закрываем scaner
        scanner.close();
    }

    static double calculateSquare(double number) {
        double result = number * number;
        return result;
    }
}
___________________________________________________________________________________________________

Задача №2 - решить квадратное уравнение (ax^2+bx+c=0)
также с помощью ввода данных через экран (консоль среды).
___________________________________________________________________________________________________
//import - это ключевое слово языка java, с помощью которого подключаются различные библиотеки
import java.util.Scanner; //это библиотека, которую необходимо импортировать в проект, для того, чтобы заюзать сканер

public class Main {
    public static void main(String[] args) { // - с этого начинает читаться программа
        //у любой консольной программы есть возможность выводить данные на экран
        //вводить данные с клавиатуры

        //сканер - это какой-то объект, котьорый позволяет нам вводить данные с клавиатуры
        // System.in - это стандартный поток ввода-----
        //                                            |
        //                                     -------
        //                                    |
        //                                    V
        Scanner scanner = new Scanner(System.in); //тут мы создали переменную scanner (объект) типа Scanner.
        // (тип данных называется Scanner) - этот тип данных создали другие программисты
        // на основе стандартных типов данных и возможностей языка джава
        // и запихнули его в стандартную библиотеку под названием java.util.Scanner
        // тип переменной ------      название переменной ---
        //                      |                          |     ---- new - означает что мы создаём переменную в "куче"
        //     -----------------                          |     |        ----- вызываем конструктор объекта (функцию, которая создаёт объект)
        //    |                                          |     |        |
        //   |         ---------------------------------      |        |
        //  |         |          ----------------------------         |      ----- конкретно этот конструктор принимает какой-то параметр.
        // |         |          |      -------------------------------      |      мы передаём туда System.in, потому что он соответствует типу,
        // |         |         |      |      -------------------------------       который может принять конструктор
        // |         |        |      |      |
        //Scanner scanner = new Scanner(System.in);

        //эту строчку мы знаем: тут в консоль выводится текст, написанный в кавычках
        System.out.print("Эта убаная задача решает квадратное уравнение: ");
        System.out.println("ax^2+bx+c=0");
        System.out.println("Введите убаные переменные a, b, c: ");

        //тут мы объявили переменную типа double, дали ей имя radius и присвоили ей значение 0
        double a = 0;
        double b = 0;
        double c = 0;
        double D = 0;
        double x1 = 0;
        double x2 = 0;

        //здесь мы у объекта сканер вызвали функцию nextDouble(), которая, очевидно, ожидает от нас, что мы введем с клавиатуры число типа double
        //программа повиснес здесь, до тех пор, пока мы не что-нибудь не наберём с клавиатуры и не нажмём энтер
        a = scanner.nextDouble(); // nextDouble() - это функция, которая возвращает значение типа дабл из объекта сканер
        b = scanner.nextDouble();
        c = scanner.nextDouble();
        D = Math.pow(b, 2) - 4 * a * c;

        //выводим то, что записалось в переменную radius
        // я думаю это не нужно System.out.printf("Радиус круга: %f \n", radius);

        //объявляем переменную типа double, даём ей имя square и записываем туда 0

        if (D > 0) {
            x1 = -b + Math.sqrt(D) / (2 * a);
            x2 = -b - Math.sqrt(D) / (2 * a);
            System.out.printf("x1 = %f, х2 = %f \n", x1, x2);
        } else if (D == 0) {
            x1 = -b / 2 * a;
            System.out.printf("D = %f \n", x1);
        } else {
            System.out.println("D<0, there is no roots, PZDUk. Get out of here!!");
        }

        scanner.close();
    }
}
___________________________________________________________________________________________________

 Задача №3 - написать код для проверки пароля, который необходимо ввести через экран (черз консоль среды)
т.е. ввести через экран пароль и проверит подходит ли он под условия: 
___________________________________________________________________________________________________
import java.util.Scanner; //это библиотека, которую необходимо импортировать в проект, для того, чтобы заюзать сканер
public class Main {
    public static void main(String[] args) { // - с этого начинает читаться программа
        Scanner scanner = new Scanner(System.in); //тут мы создали переменную scanner (объект) типа Scanner.
        System.out.print("Write any password, mudila ");
        String a = " ";
        a = scanner.next(); // nextDouble() - это функция, которая возвращает значение типа дабл из объекта сканер
        int passA = a.length();
        boolean password = passwordLengthIsCorrect(passA);
        if (passA > 8 && passA < 20) {
            System.out.printf("Your password is %s \n", password);
        }
        else {
            System.out.print("mudila");
        }
        scanner.close();
    }
    public static boolean passwordLengthIsCorrect(int length) {
        boolean result = (length > 8) && (length < 20);
        return result;
    }
}


 - Аргументы как выражения, когда в аргументах функции можно использовать другую функцию
var result = Math.min(1, 5);
 Функция Math.min вызывается с аргументами 1 и 5.
 В Жабе (java) выражения превращаются в значения. То есть с точки зрения Java, значения и выражения — это что-то схожее. Поэтому любые значения в программе технически можно заменить выражениями как 
var result = Math.min(1, 2 + 3);
 Более того, можно использовать переменные вперемешку со значениями и другими выражениями:
var number = 2 + 2;
var result = Math.min(1, 1 + number);
_____________________________________________________________________
Дебильное задание! - 
Вам доступна функция Functions.calculateDistanceBetweenTowns. Она принимает один аргумент, в котором должны содержаться названия двух городов через дефис. В ответ она возвращает расстояние между этими городами. Вот пример использования:
var distance = Functions.calculateDistanceBetweenTowns("Lannisport-Bayasabhad");
Напишите программу, которая использует функцию Functions.calculateDistanceBetweenTowns и выводит на экран расстояние между городами, записанными в переменные from и to.
_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception {
        var from = "The Twins";
        var to = "The Eyrie";

        // BEGIN
        var distance = Functions.calculateDistanceBetweenTowns(from + "-" + to);
	System.out.print(distance);
        // END
    }
}
_____________________________________________________________________

- Побочные эффекты - это действия фукции, которые помимо вычисления результата (кроме изменения переменных функции) что-то меняют в программе, например, System.out.print 
 Если какая-то функция осуществляет вычисление чего-то и при этом выводит какие-то данные на экран, то с точки зрения вычисления результата вывод на экран - побочный эффект. 
 Для print, конечно, этот термин не очень подходит, потому что именно назначение этой функции состоит в выводе на экран, то есть это ее основной эффект, а не побочный; но если мы вспомним, что с точки зрения математики функция это именно выражение результата через аргументы, а не осуществление каких-то действий, то станет понятно, почему принято любые действия функции, которые помимо вычисления результата как-то меняют что-то в программе (кроме переменных в самой функции), называть побочными эффектами.
 К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран или печать на принтере и так далее.   
			
Ещё одно "авторское" задание - выполнить его без создания переменных.
 Выведите на экран имя матери Дайнерис Таргариен (“Daenerys Targaryen”), используя функцию Functions.parentFor без создания переменных.
 Functions.parentFor принимает первым параметром имя ребенка и возвращает имя родителя. Вторым параметром функция принимает строчку father или mother. Так функция понимает, кого из родителей возвращать. По умолчанию параметр равен mother.

_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception {
        // BEGIN
       	System.out.print(Functions.parentFor("Daenerys Targaryen"));
        // END
    }
}
_____________________________________________________________________
C переменной было бы пижже и код выглядел бы куда красивее:

public class App {
    public static void main(String[] args) throws Exception {
        // BEGIN
	var ebanoe_zadanie = Functions.parentFor "Daenerys Targaryen";
       	System.out.print(ebanoe_zadanie);
        // END
    }
}
_____________________________________________________________________

- Неизменяемость аргументов функций - если вы назвали переменную (Ymnot) ebala i.e. 
ebala = Ymnot , то относительно функции f(ebala) => ebala является неизменой переменной!
____________________________________________________________________
var number = 7.7
var newNumber = Math.round(number);

System.out.print(newNumber);

8 
 Math.round вернула новые данные, но не изменила переданные в неё данные. 
Важнее, что она не могла это сделать в принципе, потому что аргументы функций в Java — неизменяемы.
_____________________________________________________________________
 Фактически, можно считать, что если функция f объявлена с каким-то аргументом arg, и она вызывается как f(number), то внутри функции есть переменная arg, и в эту переменную записывается передаваемое значение (которое в этом случае берется из переменной number). Функция может изменять свою переменную arg (находящуюся внутри функции), но такие изменения никак не повлияют на переменную number. Даже если аргумент в сигнатуре функции тоже называется number - это все равно другая переменная number, а не та, значение которой передается в функцию.

Задание: 
 Переведите строку, записанную в переменную lubaya "a mind needs books as a sword needs a whetstone, if it is to keep its edge.", в верхний регистр, используя функцию toUpperCase. 
 Новое значение запишите в ту же переменную lubaya
_____________________________________________________________________
public class App {
    public static void main(String[] args) throws Exception { 
	var lubaya = "a mind needs books as a sword needs a whetstone, if it is to keep its edge.";

        // BEGIN
        lubaya = lubaya.toUpperCase();
        // END
        System.out.print(lubaya);
_____________________________________________________________________

Список всех функций, классов и прочих операторов

https://docs.oracle.com/javase/8/docs/api/allclasses-noframe.html
_____________________________________________________________________
****
 Сигнатура функции - и любая функция фозвращает одно значение (но можно и несколько вернуть если изъебнуться нехитрым способом)
Например, функция 
	Math.min(2, 6) нахождение минимального числа из 2ух - возвращает тип одно значение типа int (в данном случае) то же время, возвращаемое значение может быть сложного типа и представлять собой, например, список каких-то значений.
	Math.pow - возведение корня в степень: Math.pow(-8, 3) (т.е. (3^√-8)) = -2;
	Math.sqrt() - возведение в квадратный корень Math.sqrt(4) (т.е. (√4)) = 2;

 
__________________________________________________________________________________________________________________________________________		


				Создание своих функций!
** функция — глагол, переменная — существительное.

		   public static void main(String[] args) {
 Код, в котором создаётся функция, называется определением функции.
Функции могут возвращать (int) или не возвращать (void) значения, 
могут вызываться с указанием параметров или без.
Тип возвращаемых данных указывают при объявлении функции — перед её именем:
_____________________________________________________________________
- void (пустота) - модификатор (для окончания программы с нулевым кодом ошибки т.е.) при котором метод (main) не возвращает никакого значения (те идет линейная читка без запоминаня чисел, слов и прочих параметров);
**можно вместо модификатора void указать модификатор int (для завершенения программы с ненулевым кодом ошибки). Тогда можно написать код по суммированию 2ух чисел и прочее..:
_____________________________________________________________________
int Sum(int first, int second) {
  return first + second;
}
int integer1 = 3;
int integer2 = 5;

int sum = Sum(integer1, integer2);
_____________________________________________________________________
- static - модификатор, при котором метод можно создавать вызывать, не создавая экземпляр содержащего его класса (т.е. функция не пользуется членами того класса, к которому относится)
- main - это точка входа в программу (Чтобы Java-приложение могло работать, в каком-то его классе обязательно нужно объявить такую функцию main, как мы делали ранее во всех примерах). main будет вызвана при запуске приложения, поэтому в ней мы и писали код, который хотели выполнить. 
 В примерах мы объявляли эту функцию в классе App 
_____________________________________________________________________
public class App {
    public static void main(String[] args)

//Вывод на экран "Za Ordu!"

static void sayZaOrdu() {
  System.out.print("Za Ordu!");
}
						Задача. Начало!
_____________________________________________________________________
Задача: Выводить на экран текст Today is: December 5.
 Нужно назвать функцию так, чтобы из названия была понятна её задача. Давайте дадим ей имя showDate:

static void showDate() {
  var text = "Today is: December 5";
  System.out.print(text);
}
Тогда полная программа будет выглядеть: 
_____________________________________________________________________
public class App {
  public static void main(String[] args) {
    App.showDate();// App - имя главного класса 
		   // showDate - название функции 
  }

  static void showDate() {
    var text = "Today is: December 5";
    System.out.print(text);
  }
}
_____________________________________________________________________

***Улучшим функцию так, чтобы она принимала дату в качестве аргумента и выводила её на экран:
_____________________________________________________________________
public class App {
  public static void main(String[] args) {
    App.showDate("January 29");// просто showDate("January 29");
  }

  static void showDate(String date) { 
//Теперь функция принимает один аргумент — date, имеющий тип String (так называется в Java тип,соответствующий строке текста)
    var text = "Today is: " + date";
    System.out.print(text);
  }
}

Today is: January 29
_____________________________________________________________________
Java работает так: переменная сама создаётся при вызове и указанное значение (в нашем примере — 'January 29') записывается в эту переменную (Аргументы можно называть как угодно, их имена имеют смысл исключительно в теле функции)

***Аргументов может быть несколько. В таком случае в определении функции мы делаем то же самое, что в вызове: просто указываем аргументы через запятую.
_____________________________________________________________________
public class App {
  public static void main(String[] args) {
    showDate("January", "29");
  }
  static void showDate(String month, String day) {
    var text = "Today is: " + month + " " + day;
    System.out.print(text);
}
_____________________________________________________________________
***можно таже в аргументах указыать ранее сформированные аргументы, НО главное, чтобы переменные аргументов были одинакого типа, т.е.:
_____________________________________________________________________
public class App {
  public static void main(String[] args) {
    showDate("January", "Qq", 22, 1);
  }
// в сформированный аргумент типа String ("January", "Qq"), которые затем используется в аргументах String day, String day
// в той же функции, также существует аргумент тип int (22, 1), которые затем используется в аргументах int num, int num1
  static void showDate(String month, String day, int num, int num1) {
    var text = "Today is";
    var strings1and2 = month + " " + day;
    var onlydata = num;
    var onlydata1 = num1;
    System.out.println(text);
    System.out.println(strings1and2);
    System.out.println(onlydata + onlydata1);
 }
}
Today is
January 29
23 (22+1) - СКЛАДЫЫВАНИЕ ЧИСЕЛ И ПРАВИЛЬНАЯ ЗАПИСЬ ПЕРЕМЕННЫХ В ФУНКЦИЮ ВЫВОДА (System.out.prtint)

_____________________________________________________________________ 
 Главное — помнить про порядок: в каком порядке стоят аргументы при определении функции showDate (относительно функции static void showDate аргументы являются переменными), в таком же порядке они должны передаваться при вызове!
					Задача. Конец! 

Задание - реализуйте функцию printJaimesLine, которая принимает один аргумент — строку, и выводит реплику на экран в формате JAIME: переданная_строка.
Моё решение: 
_____________________________________________________________________
public class App {
    public static void main (String[] args) {
        App.printJaimesLine("JAIME: "\UBUNTUAxYENNA!"");
    }
    static void printJaimesLine(String forJAIME) {
        var text = forJAIME;
        System.out.print(text); 
    } 
    
}
_____________________________________________________________________
Решение какого-то учителя: непонятная фуета 
_____________________________________________________________________
public class App {
    // BEGIN
    public static void printJaimesLine(String text) {
        System.out.print("JAIME: " + text);
    }
    // END
}
_____________________________________________________________________

- Аргументы, переменные и инструкции

Запустить код 
_____________________________________________________________________
public class App {
    public static void main (String[] args) {
	static void showDate("Today is: December 5") { // Аргумент должен быть переменной
 	// какой-нибудь код
}
_____________________________________________________________________
не получится — он содержит синтаксическую ошибку. Вместо переменной в аргументе написана строка, то есть значение. Аргумент должен быть переменной, иначе он не сможет быть аргументом, то есть чем-то, что принимает значение при вызове.

Если же вам нужна какая-то информация в функции, и вы заранее знаете, какая именно, то аргумент для этого не нужен, достаточно создать переменную в самом теле
_____________________________________________________________________
public static void showDate() {
  var text = "Today is: December 5";
  // какой-нибудь код
}
_____________________________________________________________________

 Задание - Сэм составляет множество карт, и ему часто нужно выводить на экран повторяющиеся символы для визуализации маршрутов. 
 Например, так Сэм иллюстрирует узкие дороги между городами: (Meereen =-=-=-=- Myr)
 А так иллюстрирует широкие трассы (Vaes Dothrak ======== Vahar)  
 Сэм где-то нашёл функцию repeat из класса Functions. Она принимает два аргумента: какое-то число N и строку, и возвращает повторенную N раз строку. Вот как он использует её: 
System.out.print(Functions.repeat("=-", 4)); //"=-" - повторяется 4 раза подряд
 Неудобно вызывать сотни раз repeat внутри вызова System.out.print.
 Напишите для Сэма функцию printSeq, которая сама выводит на экран получившиеся повторения. 
 Она принимает два аргумента — строку и число, и выводит повторяющуюся строку на экран. Для генерации строки используйте repeat.
 Вот пример того, как Сэм будет использовать написанную вами printSeq: App.printSeq("=-", 4);
 Функцию нужно сделать public static, а не просто static, чтобы мы смогли вызвать ее из другого класса.
_____________________________________________________________________
public class App {
    // BEGIN
    public static void printSeq(String text, int num) {
        System.out.print(Functions.repeat(text, num));
    }
    // END
}
_____________________________________________________________________

				  Задание
Cоздадим и вызовем функцию, которая принимает два числа и возвращает разность первого и второго. 
Назовём её sub, от англ. “subtract” — «вычесть»:


public class App {
	public static void main(String[] args) {
		System.out.print(App.sub(10, 7));
	}      
	static int sub(int a, int b) { //раньше стоял void, который не возвращал значения
		var text = a - b;
		return text; // вместо System.out.print (text) 
			     // функция возвращает разность первого и второго числа
	}
}

// отчие от того, что было в "СКЛАДЫЫВАНИЕ ЧИСЕЛ И ПРАВИЛЬНАЯ ЗАПИСЬ ПЕРЕМЕННЫХ В ФУНКЦИЮ ВЫВОДА"
_____________________________________________________________________
Функция — действие. Вызов функции всегда подобен указанию «сходи», «возьми», «напечатай», «положи» и так далее. Вспомните, какие функции были в предыдущих уроках:
showDate («показать дату»)
sub (subtract — «вычесть»)
print («напечатать»)
round («округлить»)
getType («получить тип»)

Переменная — сущность, поэтому мы используем существительные:
child
result
euros





						Задание. Начало! 
Сэм создаёт генеалогические деревья разных семей. Ему постоянно приходится рассчитывать количество места, занимаемое именами родителей на экране.
 Создайте функцию App.getParentNamesTotalLength для Сэма. Она должна принимать один аргумент — имя ребенка, и возвращать количество символов в именах матери и отца суммарно. Функция не должна выводить ничего на экран, только возвращать число.
 Для реализации используйте уже существующую функцию Functions.parentFor:
 Получение имени матери Functions.parentFor(child, "mother"), где child — имя ребёнка.
 Получение имени отца Functions.parentFor(child, "father"), где child — имя ребёнка
 Длину строки str можно получить таким образом: str.length() - это особый способ вызова функций, который мы подробно пока изучать не будем
 Вам не нужно вызывать свою функцию, только определить её.
 Как обычно, функцию нужно сделать public static, а не просто static, чтобы мы смогли вызвать ее из другого класса.
_____________________________________________________________________
public class App {
    // BEGIN
    public static int getParentNamesTotalLength(String child) throws Exception{
        var mother = Functions.parentFor(child, "mother");
        var father = Functions.parentFor(child, "father");
        return mother.length() + father.length();
    }
    // END
}
_____________________________________________________________________

					Задание			
Напишите функцию getAgeDifference, которая принимает два года рождения и возвращает строку с разницей в возрасте в виде The age difference is 11.
Как обычно, функцию нужно сделать public static, а не просто static, чтобы мы смогли вызвать ее из другого класса.
_____________________________________________________________________
public class App {
	public static void main(String[] args) {
		System.out.print("The age difference is " + App.getAgeDifference(2011, 2000));
// дополнительный текс "  " прописывается только здесь 
	}
	public static int getAgeDifference(int a, int b) {
		var c = a - b;
		return c;
	}
}
_____________________________________________________________________

				






Java программы состоят из 10 и 100 тысяч классов, поэтому можно упаковать касс-файлы в архив c расширеием jar, в котором содержится манифест с метаинформацией о программе (например, имя программы, версия и ИМЯ ГЛАВНОГО КЛАССА)
Для работы с архивами в jdk есть инструмент jar, чтобы упаковать файлы в архив необходимо перейти в папку, где находятся файлы, которые хотим упаковать (черз команду сd) и выполнить следующую команду:
jar cfe имя архива.jar(можно придумать любое) имя главного класса,которе будет далее прописано в Манифесте (должно совмадать с именем класса, которое прописанно в коде) далее перечисляем все файлы,которые хотим упаковать (через пробел) 
_____________________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ jar cfe ZO.jar ZaOrdu ZaOrdu.class ZaOrdu.java Konspekt1  
_____________________________________________________________________
после этого архив создатся в той папке, в которой находились исходные файлы.
Также jdk позволяет просматривать архив, не распаковывая его с помощью команды tf
jar tf имя архива.jar
_____________________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ jar tf ZO.jar
_____________________________________________________________________
После выполнения данной команды выпадает следующая информация:

META-INF/                   
META-INF/MANIFEST.MF     - тот самый манифест с метаинформацией   
ZaOrdu.class             - имя главного класса
ZaOrdu.java                    
Konspekt1
_____________________________________________________________________
Также можно распаковать архив с помощью команды xf
_____________________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ jar xf ZO.jar
_____________________________________________________________________
Архив распакуется в той же папке, в которой находится

Чтобы запустить АРХИВ, 1) в котором ПРОПИСАН главный класс, необходимо выполнить команду -jar: 
java -jar имя файла.jar
_____________________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ java -jar ZaO.jar
- ZaOrdu!
- Ебать!
_____________________________________________________________________
2) в котором НЕ ПРОПИСАН главный класс, необходимо выполнить команду -classpath:
_____________________________________________________________________
sheriff@ubuntu:~/JavaLessons/Lesson_01$ java -classpath ZaO.jar ZaOrdu
- ZaOrdu!
- Ебать!
_____________________________________________________________________

java программы часто зависят от сторонних библиотек классов (например пишешь свою прогу, для мерчендайзеров, и тебе надо штрихкоды сканировать, но ты же не будешь изобретать велосипед и сам с нуля писать код, который штрихкоды сканирует? ты как умный человек возьмёш готовую библиотеку), распространяемых как jar-архивы.
Для того чтобы скомпилировать программу, использующую сторонние классы надо объяснить компилятору, где эти классы найти через параметр classpath
_____________________________________________________________________
javac -classpath lib.jar ZaOrdu.java
_____________________________________________________________________
Виртуальной машине тоже нужно иметь доступ ко всем классам, используемым программой, поэтому существет  
Команда добавления jar в classpath виртуальной машины: 
java - classpath lib.jar:имя архива.jar имя главного класса
_____________________________________________________________________
java -classpath lib.jar:ZaO.jar ZaOrdu

sheriff@ubuntu:~/JavaLessons/Lesson_01$ java -classpath lib.jar:ZaO.jar ZaOrdu
- ZaOrdu!
- Ебать!
_____________________________________________________________________
**Важное замечание при написании кода java -classpath lib.jar:ZaO.jar ZaOrdu
В Linux разделение иде за счет : , а в windows ;

					Немного о виртуальной машине jdk
Виртуальная машина java, поставляемая Oracle в составе jdk (или jre) имеет собственное имя HotSpot (TM), чтобы увидеть имя необходимо выполнить команду: 
_____________________________________________________________________
java -version

sheriff@ubuntu:~$ java -version
java version "12.0.2" 2019-07-16
Java(TM) SE Runtime Environment (build 12.0.2+10)
Java HotSpot(TM) 64-Bit Server VM (build 12.0.2+10, mixed mode, sharing)
_____________________________________________________________________
Существуют и другие реализации java от других производителей (не HotSpot). 

Задача java машины исполнять byte code. 
НО откуда виртуальная машина знает как именно ей нужно понимать byte code и исполнять его??
Для этого Oracle с каждым релизом jdk (или jre) выпускает объемный документ под названием The java Virtual Machine Specification, в котором описан формат class - файлов, перечислены в byte code все возможные инструкции и подробно описано как именно виртуальная машина должна их исполнять.

Как JVM исполняет byte code?
- В простейшем случае она будет идти по byte code последовательно, анализировать каждую инструкцию, исполнять её и переходить к слудующей. Этот режим называется интерпритацией. 
Интерпритатор просто написан, но даже хорошо написанный самостоятельный интерпритатор будет работать медленее нативного. 
Если мы сравним интерпритаторы, записанный в машинных кодах процессора и записанный byte code, раньше машинный был быстрее в 10-20 раз, так как Java 1.0 поддерживала только режим интерпритации. В Версии Java 1.1 был довлен режим just in time - компиляции jit.
В режиме jit виртуальная машина сначала компилировала byte code в машинный код, который затем исполнятлся процессором. За последние коды jit компилятор достаточно усовершенствован и оптимизирован и теперь он способен на такие вещи, как 
- адаптивная компиляция и оптимизация byte code в зависимости от того сколько и с какими параметрами исполнится тот или иной участок кода.
В виртуальной машине java программа, запущенная в современной виртуальной машине, будет работать уже всего в 1,5-2 раза медленне, чем нативная программа, а внекоторых случаях java - программа может оказаться быстрее, т.к. HotSpot использует знания о фактическом выполнении программ, в отличии от традиционных компиляторов, которые
видят статические исходные тексты.

1.3 Знакомство со средой разработки
Для начала необходимо узнать, что у Java существует 3 основных среды для разработки (это что-то типа Sublime, только профильные с различными инструментами): IntelliJ IDEA, NetBeans, Eclipse
  IntelliJ IDEA - более практичная и удобная среда
Для написания кода необходимо запустить программу - Create New Project - Java (не ставим нигде галочки) - Create Project from template - Java Hello World - Называю имя файла как и имя главного class - в панеле управления (слева) выбираю папку src, выбираю главный класс и переименовываю его на необходимый - Refactoring - Rename
Файл готов к работе!
 Далее пишу такой же код и нажимаю на плей, программа работает. 
 Полезные функции: 
ctrl+Tab - функция перехода к объявлению класса, метода или любого другого идентификатора в программе 
ctrl+P - подсказка какие параметры ещё может применять выбранный метод 
ctrl+Q - показывает документацию на выбранный метод
_____________________________________________________________________________
Любой идентификатор в программе можно переименовать, а среда разработки сама обновит ссылки во всех местах кода на измененнный идентификатор
Также можно переименовать Исходный class, среда также сама обновит наименование исходного файла (в папке src).
 Если не обновит, в коде необходимо rename to..

В jdk есть стандартный инструмент для генерации документации по исходному коду java doc - 
https://docs.oracle.com/en/java/javase/12/docs/api/
Html - cтраница, которой перечислены все классы, методы, поля 

						Комментарии
Практически все языки программирования позволяют оставлять в коде комментарии. Они никак не используются интерпретатором и НУЖНЫ ИСКЛЮЧИТЕЛЬНО ДЛЯ ЛЮДЕЙ, ЧТОБЫ ПРОГРАММИСТ ОСТАВЛЯЛ ПОМЕТКИ ДЛЯ СЕБЯ ИЛИ ДРУГИХ ПРОГРАММИСТОВ.
В Java есть 3 вида комментариев:
_____________________________________________________________________________
public class ZaOrdu {
    public static void main(String [] args) {
        System.out.println("- ZaOrdu?");
        System.out.println("- Тогорот!");
    }
}
_____________________________________________________________________________
1ые - Обычные однострочные комметраии: 
которые начинаются с // 
После этих двух символов может следовать любой текст, вся строчка не будет анализироваться и исполняться.
Комментарий может занимать всю строчку:
_____________________________________________________________________________
// For the Orcs!
_____________________________________________________________________________
public class ZaOrdu {
    public static void main(String [] args) {
        System.out.println("- ZaOrdu?");
        System.out.println("- Тогорот!");
	// For the Orcs!
    }
}
_____________________________________________________________________________
или может находиться на строчке после какого-нибудь кода:

System.out.print("ZaOrdu?"); // For the Orcs

_____________________________________________________________________________
public class ZaOrdu {
    public static void main(String [] args) {
        System.out.println("- ZaOrdu?"); // For the Orcs
        System.out.println("- Тогорот!");
    }
}
_____________________________________________________________________________
2ые - многострочные комментарии:
начинаются с /* 
и заканчиваются
             */
Принято каждую строчку начинать с символа *, хотя технически это и не обязательно.
/*
 * At the night the power of the Orcs grows up
 * and full of terrors
 */
System.out.print("I am the King");
_____________________________________________________________________________
public class ZaOrdu {
    public static void main(String [] args) {
         /*
         * At the night the power of the Orcs grows up
 	 * and full of terrors.
         */
        System.out.println("- ZaOrdu?");// For the Orcs
        System.out.println("- Тогорот!");
        // For the Orcs    
    }
}
_____________________________________________________________________________
3ие - Документирующие комментарии 
специальные комментарии, содержащие документацию:
начинаются 		/**
            		 *
заканчиваются            */
уже для них уже обязательно каждую строчку начинать с символа *
Документирующие комментарии, являясь, по сути, подвидом многострочных, несут дополнительную функцию – они могут быть собраны при помощи специальной утилиты javadoc и выданы в качестве документации к вашему коду.
Классы стандартной библиотеки, а также многих других сторонних библиотек снабжены такими javadoc комментариями, а среды разработки умеют удобно их показывать: (например ctrl+Q - показывает документацию на выбранный метод)
_____________________________________________________________________________
/**
 *A program that prints <code>ZaOrdu</code>
 * 
 * 
 */
public class ZaOrdu {
    public static void main(String [] args) {
         /*
         * At the night the power of the Orcs grows up
 	 * and full of terrors.
         */
        System.out.println("- ZaOrdu?");// For the Orcs
        System.out.println("- Тогорот!");
        // For the Orcs    
    }
}
_____________________________________________________________________________
В java doc можно использовать обычную html разметку и некоторые специальные теги, которые подскажет среда разработки:
_____________________________________________________________________________
/**
 *A program that prints <code>ZaOrdu</code>
 *
 * @author Sheriff Master
 * @version 1.0
 */
public class ZaOrdu {
    /**
     *Programm entry point
     * @param args command-line arguments 
     */
    public static void main(String [] args) {
	/*
         * At the night the power of the Orcs grows up
 	 * and full of terrors.
         */
        System.out.println("- ZaOrdu?");// For the Orcs
        System.out.println("- Тогорот!");
        // For the Orcs  
    }
}
_____________________________________________________________________________
Также любая среда имеет удобную функцию форматирования кода, когда Вам попался код без отступов (сделать это можно при помощи Shift+Tab), можно отформатировать его при помощи функции via Ctrl+Alt+shift+L
Shift+F6 - можно поменять везде любой метод по всему файлу (привести к одному наименованию по всему коду)

Запускается написанная программа через выбор главного класса (во вкладке) - Run Main (либо Shift+Ctrl+F10)
После запуска автоматически создается Конфигурация запкска, которую можно посмотреть и настроить через Команды: 
Main - Edit configurations
В данном меню можно указать различные настройки написанной программы. В одном проекте может быть много конфигураций запуска. 
Пример: - Можно указать Придаваемые аргументы командной строки
Main - Edit configurations - Program arguments - ввод аргументов A B C - жук (дебаг) 
Перед выполнением команды Debug нужно поставить точку на System.out.println("- ZaOrdu?"), чтобы останова программы остановится на паузу в том месте, чтобы я мог постметреть значения переменных (ну то есть, если ты не будешь ставить точки останова, то у тебя программа выполнится и завершит свою работу, а если поставишь точку останова, то прога в том месте станет на паузу).
Можно также распечатать аргументы A B C 
_____________________________________________________________________________
/**
 *A program that prints <code>ZaOrdu?</code>
 *
 * @author Sheriff Master
 * @version 1.0
 */
public class ZaOrdu {
    /**
     *Programm entry point.
     *
     * @param cmdLineArgs command-line arguments
     */
    public static void main(String [] cmdLineArgs) {
        System.out.println("- ZaOrdu?");
        System.out.println("- Заебись?");

        //вывели аргументы на экран
        //cmdLineArgs - это массив
        System.out.println(cmdLineArgs[0]); // выводим на экран нулевой элемент массива
        System.out.println(cmdLineArgs[1]); // выводим на экран первый элемент массива
        System.out.println(cmdLineArgs[2]); // выводим на экран второй элемент массива

//         for(int i = 0; i < cmdLineArgs.length; i++)
//             System.out.println(cmdLineArgs[i]);

         System.out.println("> The end");
    }
}
_____________________________________________________________________________
Получаем: 
/usr/lib/jvm/jdk-12.0.2/bin/java -javaagent:/home/sheriff/idea-IC-191.7479.19/lib/idea_rt.jar=36453:/home/sheriff/idea-IC-191.7479.19/bin -Dfile.encoding=UTF-8 -classpath /home/sheriff/IdeaProjects/ZaOrdu/out/production/ZaOrdu ZaOrdu A B C
- ZaOrdu?
- Заебись?
A
B
C
> The end

Process finished with exit code 0
_____________________________________________________________________________

